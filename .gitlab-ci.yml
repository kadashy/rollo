
stages:
  - package
  - scan
  - seting-env
  - validate-version
  - build
  - publish
  - deploy


detect-secrets:
  stage: scan
  image:
    name: registrysecaas.azurecr.io/secaas/detect-secrets-cli:latest
  variables:
    SECAAS_PLUGIN_ID: $SECAAS_PLUGIN_ID
    SECAAS_PLUGIN_SECRET: $SECAAS_PLUGIN_SECRET
    BUSINESS_ID: $BUSINESS_ID
  script:
    - entrypoint detect-secrets-cli
  allow_failure: true
  except:
    - test
    - master

get_scritps:
  image: alpine
  stage: package
  script:
    - apk add git
    - git clone https://$TEMPLATE_TOKEN@$TEMPLATE_URL
    - mv pipeline-template/tools/go_job/Dockerfile Dockerfile
    - rm -rf pipeline/ci || status=1
    - mv pipeline-template/tools/go_job/pipeline/ci ci
    - chmod -R +x ci
  tags:
    - k8s-runner
  artifacts:
    paths:
      - Dockerfile
      - ci

package:
  image: golang:alpine
  stage: package
  script:
    - go version
    - apk add build-base
    - cd src/cmd/
    - go build -o rollo -ldflags "-linkmode external -extldflags -static" -a main.go
  only:
    - develop
    - test
    - master
  artifacts:
    paths:
      - src/cmd/rollo
  tags:
    - k8s-runner

credentials-dev:
  image: registrysecaas.azurecr.io/secaas/gcp-sdk:latest
  stage: seting-env
  script:
    - OWNER=$(cat pipeline/ci/.owner)
    - NSR_GCR_AUTH_OWNED=NSR_GCR_AUTH_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!NSR_GCR_AUTH_OWNED} | base64 -d > gcr_auth.json
    - gcloud auth activate-service-account --key-file=gcr_auth.json
    - GCR_PULL_KEY=$(gcloud auth print-access-token)
    - echo "$GCR_PULL_KEY" > .envdevelop
    - PROJECTID=PROJECT_ID_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!PROJECTID} > .projectiddevelop
    - cat .projectiddevelop
    - CLUSTER_NAME=CLUSTER_NAME_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!CLUSTER_NAME} > .clustername
    - CLUSTER_ZONE=CLUSTER_ZONE${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!CLUSTER_ZONE} > .clusterzone
  only:
    - develop
    - test
  tags:
    - k8s-runner
  artifacts:
    when: always
    name: ${CI_COMMIT_REF_SLUG}
    paths:
      - .projectiddevelop
      - .envdevelop
      - .version
      - .clustername
      - .clusterzone

credentials-test:
  image: registrysecaas.azurecr.io/secaas/gcp-sdk:latest
  stage: seting-env
  script:
    - OWNER=$(cat pipeline/ci/.owner)
    - NSR_GCR_AUTH_OWNED=NSR_GCR_AUTH_${OWNER}_test
    - echo ${!NSR_GCR_AUTH_OWNED} | base64 -d > gcr_auth.json
    - gcloud auth activate-service-account --key-file=gcr_auth.json
    - GCR_PULL_KEY=$(gcloud auth print-access-token)
    - echo "$GCR_PULL_KEY" > .envtest
    - PROJECTID=PROJECT_ID_${OWNER}_test
    - echo ${!PROJECTID} > .projectidtest
    - CLUSTER_NAME=CLUSTER_NAME_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!CLUSTER_NAME} > .clusternametest
    - CLUSTER_ZONE=CLUSTER_ZONE_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!CLUSTER_ZONE} > .clusterzonetest
  only:
    - test
    - master
  tags:
    - k8s-runner
  artifacts:
    when: always
    name: ${CI_COMMIT_REF_SLUG}
    paths:
      - .envtest
      - .projectidtest
      - .version
      - .clusternametest
      - .clusterzonetest

credentials-prod:
  image: registrysecaas.azurecr.io/secaas/gcp-sdk:latest
  stage: seting-env
  script:
    - OWNER=$(cat pipeline/ci/.owner)
    - NSR_GCR_AUTH_OWNED=NSR_GCR_AUTH_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!NSR_GCR_AUTH_OWNED} | base64 -d > gcr_auth.json
    - gcloud auth activate-service-account --key-file=gcr_auth.json
    - GCR_PULL_KEY=$(gcloud auth print-access-token)
    - echo "$GCR_PULL_KEY" > .envmaster
    - PROJECTID=PROJECT_ID_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!PROJECTID} > .projectidmaster
    - cat .projectidmaster
    - CLUSTER_NAME=CLUSTER_NAME_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!CLUSTER_NAME} > .clusternamemaster
    - CLUSTER_ZONE=CLUSTER_ZONE_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!CLUSTER_ZONE} > .clusterzonemaster
  only:
    - master
  tags:
    - k8s-runner
  artifacts:
    when: always
    name: ${CI_COMMIT_REF_SLUG}
    paths:
      - .envmaster
      - .projectidmaster
      - .version
      - .clusternamemaster
      - .clusterzonemaster

validate-version:
  image: registrysecaas.azurecr.io/secaas/gcp-sdk:latest
  stage: validate-version
  script:
    - OWNER=$(cat pipeline/ci/.owner)
    - NSR_GCR_AUTH_OWNED=NSR_GCR_AUTH_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!NSR_GCR_AUTH_OWNED} | base64 -d > gcr_auth.json
    - gcloud auth activate-service-account --key-file=gcr_auth.json
    - PROJECTID=$(cat .projectid${CI_COMMIT_REF_SLUG})
    - echo $PROJECTID
    - GCR_PULL_KEY=$(cat .env${CI_COMMIT_REF_SLUG})
    - VERSION=$(cat .version)
    - echo $VERSION
    - TAGS_GCP=$(gcloud container images list-tags --filter="tags:${CI_COMMIT_REF_SLUG}-$VERSION" --format=json us.gcr.io/"${PROJECTID}"/"${CI_PROJECT_NAME}")
    - echo $TAGS_GCP >> .tags_gcp
    - echo $TAGS_GCP
  only:
    - develop
    - test
    - master
  tags:
    - k8s-runner
  artifacts:
    when: always
    name: ${CI_COMMIT_REF_SLUG}
    paths:
      - .tags_gcp

build-dev:
  image: docker:stable-dind
  stage: build
  services:
    - docker:18.09.7-dind
  script:
    - mkdir ~/.docker
    - echo $DOCKER_AUTH_CONFIG >> ~/.docker/config.json
    - VERSION=$(cat .version)
    - PROJECTID=$(cat .projectiddevelop)
    - TAGS_GCP=$(cat .tags_gcp)
    - docker build -t us.gcr.io/${PROJECTID}/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION   .
    - GCR_PULL_KEY=$(cat .envdevelop)
    - docker login -u oauth2accesstoken -p $GCR_PULL_KEY us.gcr.io
    - if [[ "$TAGS_GCP" == "[]" ]]; then  docker push us.gcr.io/"${PROJECTID}"/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION  ; else  echo "Este TAG ya existe:" "${CI_PROJECT_NAME}":"$VERSION"  "NO se publicaran los cambios" && exit 1; fi
  allow_failure: true
  only:
    - develop
    - test
  tags:
    - k8s-runner

build-test:
  image: docker:stable-dind
  stage: build
  services:
    - docker:18.09.7-dind
  script:
    - mkdir ~/.docker
    - echo $DOCKER_AUTH_CONFIG >> ~/.docker/config.json
    - VERSION=$(cat .version)
    - GCR_PULL_KEY=$(cat .envdevelop)
    - PROJECTID=$(cat .projectidtest)
    - TAGS_GCP=$(cat .tags_gcp)
    - docker login -u oauth2accesstoken -p $GCR_PULL_KEY us.gcr.io
    - docker pull us.gcr.io/$PROJECTID/"${CI_PROJECT_NAME}":develop-$VERSION
    - docker tag us.gcr.io/$PROJECTID/"${CI_PROJECT_NAME}":develop-$VERSION   us.gcr.io/$PROJECTID/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION
    - GCR_PULL_KEY_TEST=$(cat .envtest)
    - docker login -u oauth2accesstoken -p $GCR_PULL_KEY_TEST us.gcr.io
    - docker push us.gcr.io/$PROJECTID/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION
  allow_failure: true
  only:
    - test
  tags:
    - k8s-runner

build-master:
  image: docker:stable-dind
  stage: build
  services:
    - docker:18.09.7-dind
  script:
    - mkdir ~/.docker
    - echo $DOCKER_AUTH_CONFIG >> ~/.docker/config.json
    - VERSION=$(cat .version)
    - GCR_PULL_KEY=$(cat .envtest)
    - PROJECTID_TEST=$(cat .projectidtest)
    - PROJECTID_MASTER=$(cat .projectidmaster)
    - TAGS_GCP=$(cat .tags_gcp)
    # - if [[ "$TAGS_GCP" == "[]" ]]; then  docker push us.gcr.io/"${PROJECTID}"/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION  ; else  echo "Este TAG ya existe:" "${CI_PROJECT_NAME}":"$VERSION"  "NO se publicaran los cambios" && exit 1; fi
    - docker login -u oauth2accesstoken -p $GCR_PULL_KEY us.gcr.io
    - docker pull us.gcr.io/$PROJECTID_TEST/"${CI_PROJECT_NAME}":test-$VERSION
    - docker tag us.gcr.io/$PROJECTID_TEST/"${CI_PROJECT_NAME}":test-$VERSION   us.gcr.io/$PROJECTID_MASTER/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION
    - GCR_PULL_KEY_MASTER=$(cat .envmaster)
    - docker login -u oauth2accesstoken -p $GCR_PULL_KEY_MASTER us.gcr.io
    - docker push us.gcr.io/$PROJECTID_MASTER/"${CI_PROJECT_NAME}":${CI_COMMIT_REF_SLUG}-$VERSION
  allow_failure: true
  only:
    - master
  tags:
    - k8s-runner

deploy-test:
  image: sodimacdad.azurecr.io/sodimac-dad/docker-kube-gutil:stable
  stage: deploy
  script:
    - export VERSION=$(cat .version)
    - export PROJECTID=$(cat .projectidtest)
    - CLUSTER_NAME=$(cat .clusternametest)
    - CLUSTER_ZONE=$(cat .clusterzonetest)
    - OWNER=$(cat pipeline/ci/.owner)
    - NSR_GKE_AUTH_OWNED=NSR_GKE_AUTH_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!NSR_GKE_AUTH_OWNED} | base64 -d > gke_auth.json
    - export EXTENV=lst
    - export VARENV=TS
    - export ENVIRONMENT=test
    - export APPNAME=${CI_PROJECT_NAME//-/}
    - gcloud auth activate-service-account --key-file gke_auth.json
    - gcloud config set project $PROJECTID
    - gcloud container clusters get-credentials $CLUSTER_NAME --zone $CLUSTER_ZONE --project $PROJECTID
    - bash ci/replace.sh
    - kubectl delete cronjob ${CI_PROJECT_NAME}-${ENVIRONMENT} -n jobs || status=1
    - kubectl apply -f pipeline/cd/job.yml
    - kubectl get cronjobs
  only:
    - test
  tags:
    - k8s-runner

deploy-prod:
  image: sodimacdad.azurecr.io/sodimac-dad/docker-kube-gutil:stable
  stage: deploy
  script:
    - export VERSION=$(cat .version)
    - export PROJECTID=$(cat .projectidmaster)
    - CLUSTER_NAME=$(cat .clusternamemaster)
    - CLUSTER_ZONE=$(cat .clusterzonemaster)
    - OWNER=$(cat pipeline/ci/.owner)
    - NSR_GKE_AUTH_OWNED=NSR_GKE_AUTH_${OWNER}_${CI_COMMIT_REF_SLUG}
    - echo ${!NSR_GKE_AUTH_OWNED} | base64 -d > gke_auth.json
    - export EXTENV=prd
    - export VARENV=PR
    - export ENVIRONMENT=prod
    - export APPNAME=${CI_PROJECT_NAME//-/}
    - gcloud auth activate-service-account --key-file gke_auth.json
    - gcloud config set project $PROJECTID
    - gcloud container clusters get-credentials $CLUSTER_NAME --zone $CLUSTER_ZONE --project $PROJECTID
    - bash ci/replace.sh
    - kubectl delete cronjob ${CI_PROJECT_NAME}-${ENVIRONMENT} -n jobs || status=1
    - kubectl apply -f pipeline/cd/job.yml
    - kubectl get cronjobs
  only:
    - master
  tags:
    - k8s-runner
